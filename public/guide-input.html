<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Guida - Dual Device Mode</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }

    .container {
      background: white;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      padding: 40px;
      max-width: 600px;
      width: 100%;
    }

    h1 {
      color: #333;
      margin-bottom: 10px;
      font-size: 28px;
      text-align: center;
    }

    .subtitle {
      color: #666;
      text-align: center;
      margin-bottom: 30px;
      font-size: 14px;
    }

    .info-box {
      background: #fef3c7;
      border-left: 4px solid #f59e0b;
      padding: 15px;
      margin-bottom: 25px;
      border-radius: 8px;
      font-size: 13px;
      color: #92400e;
      line-height: 1.6;
    }

    .form-group {
      margin-bottom: 20px;
    }

    label {
      display: block;
      color: #555;
      font-weight: 500;
      margin-bottom: 8px;
      font-size: 14px;
    }

    select {
      width: 100%;
      padding: 12px 16px;
      border: 2px solid #e0e0e0;
      border-radius: 10px;
      font-size: 16px;
      background: white;
    }

    select:focus {
      outline: none;
      border-color: #f59e0b;
    }

    .btn {
      width: 100%;
      padding: 14px;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      margin-top: 10px;
    }

    .btn-primary {
      background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
      color: white;
    }

    .btn-primary:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(245, 158, 11, 0.4);
    }

    .btn-primary:disabled {
      background: #d1d5db;
      cursor: not-allowed;
    }

    .btn-danger {
      background: #ef4444;
      color: white;
    }

    .btn-danger:hover {
      background: #dc2626;
    }

    .status {
      text-align: center;
      padding: 12px;
      border-radius: 10px;
      margin-top: 20px;
      font-size: 14px;
      font-weight: 500;
    }

    .status.inactive  { background: #f3f4f6; color: #6b7280; }
    .status.connecting{ background: #fef3c7; color: #92400e; }
    .status.active    { background: #d1fae5; color: #065f46; }
    .status.listening { background: #dbeafe; color: #1e40af; }

    .hidden { display: none; }

    .preset-selector {
      display: flex;
      gap: 8px;
      margin-top: 8px;
    }

    .preset-option {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px 8px;
      border: 2px solid #e0e0e0;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s;
      background: white;
    }

    .preset-option:hover { border-color: #f59e0b; }

    .preset-option input { display: none; }

    .preset-option input:checked + .preset-label { font-weight: 700; }

    .preset-option:has(input:checked) {
      border-color: #f59e0b;
      background: #fef3c7;
    }

    .preset-label {
      font-size: 13px;
      font-weight: 500;
      color: #333;
    }

    .preset-desc {
      font-size: 10px;
      color: #888;
      margin-top: 2px;
    }

    .preset-hint {
      font-size: 11px;
      color: #888;
      text-align: center;
      margin-top: 8px;
    }

    .wake-lock-badge {
      text-align: center;
      font-size: 12px;
      color: #065f46;
      background: #d1fae5;
      padding: 6px 12px;
      border-radius: 8px;
      margin-top: 10px;
    }

    .mic-group {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .mic-group select { flex: 1; }

    .mic-refresh {
      padding: 10px 14px;
      border: 2px solid #e0e0e0;
      border-radius: 10px;
      background: white;
      cursor: pointer;
      font-size: 16px;
      line-height: 1;
    }

    .mic-refresh:hover { border-color: #f59e0b; }

    .stats {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
      margin-top: 20px;
    }

    .stat-box {
      background: #f9fafb;
      padding: 12px;
      border-radius: 8px;
      text-align: center;
    }

    .stat-label {
      font-size: 11px;
      color: #6b7280;
      text-transform: uppercase;
      margin-bottom: 5px;
    }

    .stat-value {
      font-size: 20px;
      font-weight: 600;
      color: #f59e0b;
    }

    .transcript {
      margin-top: 20px;
      padding: 15px;
      background: #f9fafb;
      border-radius: 10px;
      max-height: 200px;
      overflow-y: auto;
    }

    .transcript h3 {
      font-size: 12px;
      color: #6b7280;
      margin-bottom: 10px;
      text-transform: uppercase;
    }

    .transcript p {
      font-size: 13px;
      color: #333;
      line-height: 1.6;
      margin: 5px 0;
      padding: 8px;
      background: white;
      border-radius: 6px;
    }

    /* ==========================================
       ADVANCED PARAMS PANEL
       ========================================== */

    .params-panel {
      margin-top: 15px;
      border: 2px solid #e0e0e0;
      border-radius: 10px;
      overflow: hidden;
    }

    .params-toggle {
      width: 100%;
      padding: 10px 15px;
      background: #fef3c7;
      border: none;
      border-bottom: 2px solid transparent;
      text-align: left;
      font-size: 13px;
      font-weight: 600;
      color: #92400e;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-family: inherit;
      transition: background 0.2s;
    }

    .params-toggle:hover { background: #fde68a; }
    .params-toggle.open  { border-bottom-color: #e0e0e0; }

    .params-body {
      padding: 12px 15px 15px;
      display: none;
    }

    .params-body.open { display: block; }

    .params-section {
      font-size: 10px;
      text-transform: uppercase;
      color: #999;
      font-weight: 700;
      letter-spacing: 0.5px;
      margin: 12px 0 6px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .params-section:first-child { margin-top: 0; }

    .param-row {
      display: grid;
      grid-template-columns: 1fr 110px 42px;
      align-items: center;
      gap: 8px;
      margin-bottom: 7px;
    }

    .param-label {
      font-size: 11px;
      color: #555;
    }

    .param-slider {
      -webkit-appearance: none;
      appearance: none;
      height: 4px;
      border-radius: 2px;
      background: #e0e0e0;
      outline: none;
      cursor: pointer;
    }

    .param-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #f59e0b;
      border-radius: 50%;
      cursor: pointer;
    }

    .param-slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: #f59e0b;
      border-radius: 50%;
      border: none;
      cursor: pointer;
    }

    .param-value {
      font-size: 11px;
      font-weight: 600;
      color: #f59e0b;
      text-align: right;
      white-space: nowrap;
    }

    .vad-badge {
      font-size: 10px;
      color: #065f46;
      background: #d1fae5;
      padding: 2px 6px;
      border-radius: 4px;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .vad-badge.visible { opacity: 1; }

    .params-reset {
      margin-top: 12px;
      padding: 7px 14px;
      font-size: 12px;
      background: #f3f4f6;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      cursor: pointer;
      color: #555;
      font-family: inherit;
      width: 100%;
      transition: all 0.2s;
    }

    .params-reset:hover {
      background: #fef3c7;
      border-color: #f59e0b;
      color: #92400e;
    }

    /* ---- Preset status badge in toggle ---- */
    .preset-status-badge {
      font-size: 10px;
      font-weight: 600;
      padding: 2px 7px;
      border-radius: 10px;
      background: #e5e7eb;
      color: #6b7280;
      margin: 0 4px;
      transition: all 0.2s;
    }
    .preset-status-badge.matched { background: #d1fae5; color: #065f46; }
    .preset-status-badge.custom  { background: #fef3c7; color: #92400e; }

    /* ---- Preset mini buttons ---- */
    .params-presets-mini {
      display: flex;
      gap: 6px;
      margin-bottom: 10px;
    }
    .preset-mini {
      flex: 1;
      padding: 6px 4px;
      font-size: 11px;
      font-weight: 600;
      border: 1.5px solid #e0e0e0;
      border-radius: 8px;
      background: white;
      cursor: pointer;
      color: #555;
      transition: all 0.2s;
      font-family: inherit;
    }
    .preset-mini:hover { border-color: #f59e0b; color: #b45309; }
    .preset-mini.active { border-color: #f59e0b; background: #fef3c7; color: #b45309; }

    /* ---- Redesigned param row ---- */
    .param-row {
      margin-bottom: 10px;
    }
    .param-header {
      display: flex;
      align-items: center;
      margin-bottom: 3px;
      gap: 4px;
    }
    .param-label-text {
      font-size: 11px;
      color: #555;
      flex: 1;
    }
    .tip-btn {
      background: none;
      border: 1px solid #ccc;
      border-radius: 50%;
      width: 15px;
      height: 15px;
      font-size: 9px;
      cursor: pointer;
      color: #999;
      line-height: 1;
      padding: 0;
      flex-shrink: 0;
    }
    .tip-btn:hover { border-color: #f59e0b; color: #b45309; }
    .param-track {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .param-track .param-slider { flex: 1; }
    .param-edge {
      font-size: 9px;
      color: #aaa;
      white-space: nowrap;
      min-width: 28px;
    }
    .param-edge:last-child { text-align: right; }
    .param-tip {
      font-size: 11px;
      color: #555;
      background: #fffbeb;
      border-left: 3px solid #f59e0b;
      padding: 4px 8px;
      border-radius: 4px;
      margin-top: 4px;
      line-height: 1.4;
    }
    .preset-ruler {
      position: relative;
      height: 14px;
      margin: 1px 0 0;
      padding: 0 2px;
    }
    .preset-dot {
      position: absolute;
      transform: translateX(-50%);
      font-size: 8px;
      font-weight: 700;
      color: white;
      border-radius: 3px;
      padding: 1px 3px;
      line-height: 1.4;
      top: 0;
      white-space: nowrap;
    }
    .preset-dot.s { background: #f59e0b; }
    .preset-dot.e { background: #6366f1; }
    .preset-dot.n { background: #3b82f6; }

    /* ---- Extended stats row ---- */
    .stats-sm {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 8px;
      margin-top: 8px;
    }
    .stat-value.sm { font-size: 15px; }

    /* ---- Export log button ---- */
    .btn-export {
      width: 100%;
      padding: 8px;
      margin-top: 8px;
      border: 1.5px solid #10b981;
      border-radius: 8px;
      background: white;
      color: #065f46;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      font-family: inherit;
      transition: background 0.2s;
    }
    .btn-export:hover { background: #d1fae5; }
  </style>
</head>
<body>
  <div class="container">
    <h1>üé§ Guida - Input</h1>
    <p class="subtitle">Dual Device Mode - Device Guida ¬∑ v3</p>

    <div class="info-box">
      <strong>‚ö†Ô∏è Importante:</strong> Questa √® la pagina per la GUIDA.<br>
      ‚Ä¢ Tu parli in <strong>italiano</strong> (o la tua lingua)<br>
      ‚Ä¢ Seleziona la lingua in cui <strong>tradurre</strong> (es. English)<br>
      ‚Ä¢ Sul device ricevitore, apri <strong>/visitor.html</strong> con la stessa lingua
    </div>

    <div id="setupForm">
      <div class="form-group">
        <label for="targetLanguage">üåç Traduci in:</label>
        <select id="targetLanguage">
          <option value="en">English</option>
          <option value="es">Espa√±ol</option>
          <option value="fr">Fran√ßais</option>
          <option value="de">Deutsch</option>
          <option value="pt">Portugu√™s</option>
          <option value="zh">‰∏≠Êñá</option>
          <option value="ja">Êó•Êú¨Ë™û</option>
          <option value="ko">ÌïúÍµ≠Ïñ¥</option>
          <option value="ar">ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</option>
          <option value="ru">–†—É—Å—Å–∫–∏–π</option>
        </select>
      </div>

      <div class="form-group">
        <label>‚ö° Stile traduzione:</label>
        <div class="preset-selector">
          <label class="preset-option">
            <input type="radio" name="preset" value="simultaneous" checked>
            <span class="preset-label">üü¢ Simultaneo</span>
            <span class="preset-desc">Rapido</span>
          </label>
          <label class="preset-option">
            <input type="radio" name="preset" value="balanced">
            <span class="preset-label">‚ö™ Equilibrato</span>
            <span class="preset-desc">Compromesso</span>
          </label>
          <label class="preset-option">
            <input type="radio" name="preset" value="natural">
            <span class="preset-label">üîµ Naturale</span>
            <span class="preset-desc">Frasi complete</span>
          </label>
        </div>
        <p class="preset-hint">Pi√π veloce ‚Üí meno ritardo | Pi√π naturale ‚Üí frasi pi√π complete</p>
      </div>

      <div class="form-group">
        <label for="micSelect">üé§ Microfono:</label>
        <div class="mic-group">
          <select id="micSelect"><option value="">Default del sistema</option></select>
          <button type="button" class="mic-refresh" id="micRefresh" title="Aggiorna lista">üîÑ</button>
        </div>
      </div>

      <button class="btn btn-primary" id="startBtn">
        Avvia Modalit√† Guida
      </button>
    </div>

    <div id="activeSession" class="hidden">
      <div class="status inactive" id="status">Inattivo</div>
      <div class="wake-lock-badge" id="wakeLockBadge" style="display:none">üîí Schermo attivo</div>

      <div class="stats">
        <div class="stat-box">
          <div class="stat-label">Chunk Inviati</div>
          <div class="stat-value" id="chunksSent">0</div>
        </div>
        <div class="stat-box">
          <div class="stat-label">Ricevitore</div>
          <div class="stat-value" id="receiverStatus">üî¥</div>
        </div>
        <div class="stat-box">
          <div class="stat-label">Ritardo</div>
          <div class="stat-value" id="latencyDisplay">--</div>
        </div>
      </div>

      <div class="transcript">
        <h3>Testo Rilevato (IT)</h3>
        <div id="transcriptLog"></div>
      </div>

      <!-- Extended stats: buffer, words/min, session timer -->
      <div class="stats-sm" id="extGuideStats">
        <div class="stat-box">
          <div class="stat-label">Buffer</div>
          <div class="stat-value sm" id="bufferLen">0c</div>
        </div>
        <div class="stat-box">
          <div class="stat-label">Parole/min</div>
          <div class="stat-value sm" id="wordsPerMin">‚Äî</div>
        </div>
        <div class="stat-box">
          <div class="stat-label">Sessione</div>
          <div class="stat-value sm" id="sessionTimer">00:00</div>
        </div>
      </div>

      <!-- Export session log -->
      <button class="btn-export" id="exportLogBtn">üìä Esporta Log Sessione</button>

      <!-- Advanced parameters panel (visible during active session) -->
      <div class="params-panel" id="paramsPanel">
        <button class="params-toggle" id="paramsToggle">
          <span>‚öôÔ∏è Parametri Avanzati</span>
          <span id="presetBadge" class="preset-status-badge"></span>
          <span id="paramsArrow">‚ñº</span>
        </button>
        <div class="params-body" id="paramsBody">
          <!-- Preset quick-select buttons (generated by JS) -->
          <div class="params-presets-mini" id="paramsMiniPresets"></div>
          <!-- Slider rows (generated dynamically by initParamsPanel()) -->
          <div id="paramsSliders"></div>
          <button class="params-reset" id="paramsReset">‚Ü© Reset al preset</button>
        </div>
      </div>

      <button class="btn btn-danger" id="stopBtn">
        Termina Sessione
      </button>
    </div>
  </div>

  <script type="module">
    import { RealtimeAgent, RealtimeSession, OpenAIRealtimeWebRTC } from '@openai/agents-realtime';

    // Translation style presets
    const PRESETS = {
      simultaneous: {
        name: 'Simultaneo',
        MICRO_MAX_CHARS: 100,
        MICRO_MIN_CHARS: 20,
        MICRO_FLUSH_MS: 650,
        MIN_SEND_GAP_MS: 200,
        STT_PAUSE_MS: 450
      },
      balanced: {
        name: 'Equilibrato',
        MICRO_MAX_CHARS: 140,
        MICRO_MIN_CHARS: 35,
        MICRO_FLUSH_MS: 900,
        MIN_SEND_GAP_MS: 280,
        STT_PAUSE_MS: 600
      },
      natural: {
        name: 'Naturale',
        MICRO_MAX_CHARS: 200,
        MICRO_MIN_CHARS: 50,
        MICRO_FLUSH_MS: 1400,
        MIN_SEND_GAP_MS: 350,
        STT_PAUSE_MS: 800
      }
    };

    // Default VAD values (used by reset-to-preset)
    const VAD_DEFAULTS = { threshold: 0.45, silenceDurationMs: 750 };

    class GuideInput {
      constructor() {
        this.session = null;
        this.agent = null;
        this.isRunning = false;
        this.targetLanguage = 'en';
        this.chunksSent = 0;
        this.sequenceNumber = 0;

        // Micro-chunking state - initialized from preset
        this.microBuffer = '';
        this.microFlushTimer = null;
        this.speechStoppedTimer = null;
        this.muteInterval = null;
        this.currentPreset = 'simultaneous';
        this.applyPreset(this.currentPreset);

        // Dedup state
        this.lastSentText = '';
        this.lastSentAt = 0;

        // Anti-burst / FIFO send queue
        this.lastSendAt = 0;
        this._sendQueue = [];
        this._sendProcessing = false;

        // Wake lock
        this.wakeLock = null;

        // Delta tracking
        this.gotDelta = false;

        // Latency tracking
        this.chunkLatencies = [];
        this.latencyDisplayEl = null;

        // STT activity tracking for pause flush
        this.lastSttActivityTime = Date.now();
        this.sttPauseInterval = null;

        // Mic stream
        this.micStream = null;

        // Advanced params: VAD + TTS rate (adjustable via panel)
        this.vadThreshold   = VAD_DEFAULTS.threshold;
        this.silDurationMs  = VAD_DEFAULTS.silenceDurationMs;
        this.ttsRate        = 1.0;
        this._vadTimer      = null;  // debounce for VAD session.update

        // VAD ack tracking
        this._pendingVADUpdate = false;
        this._vadAckTimeout    = null;

        // Extended stats
        this.sessionStartTime = null;
        this.wordEvents       = [];   // [{count, time}] for words/min rolling window
        this._statsInterval   = null;

        this.initializeUI();
      }

      applyPreset(presetName) {
        const preset = PRESETS[presetName] || PRESETS.simultaneous;
        this.currentPreset = presetName;
        this.MICRO_MAX_CHARS = preset.MICRO_MAX_CHARS;
        this.MICRO_MIN_CHARS = preset.MICRO_MIN_CHARS;
        this.MICRO_FLUSH_MS  = preset.MICRO_FLUSH_MS;
        this.MIN_SEND_GAP_MS = preset.MIN_SEND_GAP_MS;
        this.STT_PAUSE_MS    = preset.STT_PAUSE_MS;
        console.log(`[Guide] Applied preset: ${preset.name}`, preset);
      }

      initializeUI() {
        this.setupForm        = document.getElementById('setupForm');
        this.activeSession    = document.getElementById('activeSession');
        this.status           = document.getElementById('status');
        this.chunksSentEl     = document.getElementById('chunksSent');
        this.receiverStatusEl = document.getElementById('receiverStatus');
        this.transcriptLog    = document.getElementById('transcriptLog');
        this.targetLanguageSelect = document.getElementById('targetLanguage');
        this.startBtn         = document.getElementById('startBtn');
        this.stopBtn          = document.getElementById('stopBtn');
        this.micSelect        = document.getElementById('micSelect');
        this.micRefresh       = document.getElementById('micRefresh');
        this.wakeLockBadge    = document.getElementById('wakeLockBadge');
        this.latencyDisplayEl = document.getElementById('latencyDisplay');

        this.startBtn.addEventListener('click', () => this.start());
        this.stopBtn.addEventListener('click', () => this.stop());
        this.micRefresh.addEventListener('click', () => this.enumerateMics());
        this.enumerateMics();

        this.initParamsPanel();

        document.addEventListener('visibilitychange', async () => {
          if (document.visibilityState === 'visible' && this.isRunning && !this.wakeLock) {
            await this.requestWakeLock();
          }
        });
      }

      // ==========================================
      // ADVANCED PARAMS PANEL
      // ==========================================

      initParamsPanel() {
        const toggle = document.getElementById('paramsToggle');
        const body   = document.getElementById('paramsBody');
        const arrow  = document.getElementById('paramsArrow');

        toggle.addEventListener('click', () => {
          const open = body.classList.toggle('open');
          toggle.classList.toggle('open', open);
          arrow.textContent = open ? '‚ñ≤' : '‚ñº';
        });

        // === Slider definitions with full metadata for dynamic rendering ===
        this._sliderDefs = [
          {
            section: 'Micro-chunking',
            sl: 'sttPause', label: 'Pausa STT',
            tip: 'Silenzio necessario per inviare il buffer al server',
            min: 200, max: 1500, step: 50, minLabel: '200ms', maxLabel: '1.5s',
            presets: { simultaneous: 450, balanced: 600, natural: 800 },
            lsKey: 'gp_sttPause', fmt: v => v + 'ms',
            get: () => this.STT_PAUSE_MS,
            set: v => { this.STT_PAUSE_MS = v; }
          },
          {
            sl: 'minChars', label: 'Min chunk',
            tip: 'Sotto questa soglia il testo attende pi√π contenuto prima di inviare',
            min: 10, max: 80, step: 5, minLabel: '10c', maxLabel: '80c',
            presets: { simultaneous: 20, balanced: 35, natural: 50 },
            lsKey: 'gp_minChars', fmt: v => v + 'c',
            get: () => this.MICRO_MIN_CHARS,
            set: v => { this.MICRO_MIN_CHARS = v; }
          },
          {
            sl: 'maxChars', label: 'Max chunk',
            tip: 'Raggiunta questa soglia, il buffer viene inviato immediatamente',
            min: 60, max: 300, step: 10, minLabel: '60c', maxLabel: '300c',
            presets: { simultaneous: 100, balanced: 140, natural: 200 },
            lsKey: 'gp_maxChars', fmt: v => v + 'c',
            get: () => this.MICRO_MAX_CHARS,
            set: v => { this.MICRO_MAX_CHARS = v; }
          },
          {
            sl: 'flushMs', label: 'Flush timer',
            tip: 'Timer di sicurezza: invia il buffer anche se non arriva nuovo testo',
            min: 300, max: 2000, step: 50, minLabel: '300ms', maxLabel: '2s',
            presets: { simultaneous: 650, balanced: 900, natural: 1400 },
            lsKey: 'gp_flushMs', fmt: v => v + 'ms',
            get: () => this.MICRO_FLUSH_MS,
            set: v => { this.MICRO_FLUSH_MS = v; }
          },
          {
            sl: 'gapMs', label: 'Gap invii',
            tip: 'Intervallo minimo tra due POST consecutivi al server',
            min: 100, max: 500, step: 25, minLabel: '100ms', maxLabel: '500ms',
            presets: { simultaneous: 200, balanced: 280, natural: 350 },
            lsKey: 'gp_gapMs', fmt: v => v + 'ms',
            get: () => this.MIN_SEND_GAP_MS,
            set: v => { this.MIN_SEND_GAP_MS = v; }
          },
          {
            section: 'VAD OpenAI', vadSection: true,
            sl: 'vadThr', label: 'Soglia VAD',
            tip: 'Pi√π bassa = pi√π sensibile al rumore. Default: 0.45',
            min: 0.10, max: 0.90, step: 0.05, minLabel: '0.10', maxLabel: '0.90',
            presets: { simultaneous: 0.45, balanced: 0.45, natural: 0.45 },
            lsKey: 'gp_vadThr', fmt: v => v.toFixed(2),
            get: () => this.vadThreshold,
            set: v => { this.vadThreshold = v; this._scheduleVADUpdate(); }
          },
          {
            sl: 'silDur', label: 'Silenzio VAD',
            tip: 'Quanto silenzio per considerare finita la frase. Default: 750ms',
            min: 300, max: 2000, step: 50, minLabel: '300ms', maxLabel: '2s',
            presets: { simultaneous: 750, balanced: 750, natural: 750 },
            lsKey: 'gp_silDur', fmt: v => v + 'ms',
            get: () => this.silDurationMs,
            set: v => { this.silDurationMs = v; this._scheduleVADUpdate(); }
          },
          {
            section: 'Visitor TTS',
            sl: 'ttsRate', label: 'Velocit√† TTS',
            tip: 'Velocit√† di riproduzione sul dispositivo visitor (1.0 = normale)',
            min: 0.5, max: 2.0, step: 0.1, minLabel: '0.5√ó', maxLabel: '2√ó',
            presets: { simultaneous: 1.0, balanced: 1.0, natural: 1.0 },
            lsKey: 'gp_ttsRate', fmt: v => v.toFixed(1) + 'x',
            get: () => this.ttsRate,
            set: v => { this.ttsRate = v; this._sendTTSRate(v); }
          }
        ];

        // === Generate preset mini buttons ===
        const miniContainer = document.getElementById('paramsMiniPresets');
        [
          { key: 'simultaneous', label: '‚ö° Simultaneo' },
          { key: 'balanced',     label: '‚öñÔ∏è Equilibrato' },
          { key: 'natural',      label: 'üéØ Naturale' }
        ].forEach(({ key, label }) => {
          const btn = document.createElement('button');
          btn.className = 'preset-mini';
          btn.type = 'button';
          btn.dataset.preset = key;
          btn.textContent = label;
          btn.addEventListener('click', () => this._resetToPresetKey(key));
          miniContainer.appendChild(btn);
        });

        // === Generate slider rows dynamically ===
        const slidersContainer = document.getElementById('paramsSliders');
        this._sliderDefs.forEach(def => {
          // Section header
          if (def.section) {
            const sec = document.createElement('div');
            sec.className = 'params-section';
            if (def.vadSection) {
              sec.textContent = def.section + ' ';
              const badge = document.createElement('span');
              badge.className = 'vad-badge';
              badge.id = 'vadBadge';
              badge.textContent = '‚úì inviato';
              sec.appendChild(badge);
            } else {
              sec.textContent = def.section;
            }
            slidersContainer.appendChild(sec);
          }

          const row = document.createElement('div');
          row.className = 'param-row';

          // Header: label + tip button + value
          const header = document.createElement('div');
          header.className = 'param-header';

          const labelSpan = document.createElement('span');
          labelSpan.className = 'param-label-text';
          labelSpan.textContent = def.label;

          const tipBtn = document.createElement('button');
          tipBtn.className = 'tip-btn';
          tipBtn.type = 'button';
          tipBtn.setAttribute('aria-label', 'info');
          tipBtn.tabIndex = -1;
          tipBtn.textContent = '?';
          tipBtn.addEventListener('click', () => {
            const tip = document.getElementById(`tip_${def.sl}`);
            if (!tip) return;
            const wasHidden = tip.hidden;
            this._sliderDefs.forEach(d => {
              const t = document.getElementById(`tip_${d.sl}`);
              if (t) t.hidden = true;
            });
            tip.hidden = !wasHidden;
          });

          const valEl = document.createElement('span');
          valEl.className = 'param-value';
          valEl.id = `val_${def.sl}`;
          valEl.textContent = '--';

          header.appendChild(labelSpan);
          header.appendChild(tipBtn);
          header.appendChild(valEl);

          // Track: min label + slider + max label
          const track = document.createElement('div');
          track.className = 'param-track';

          const minLbl = document.createElement('span');
          minLbl.className = 'param-edge';
          minLbl.textContent = def.minLabel;

          const input = document.createElement('input');
          input.type = 'range';
          input.className = 'param-slider';
          input.id = `sl_${def.sl}`;
          input.min = def.min;
          input.max = def.max;
          input.step = def.step;

          const maxLbl = document.createElement('span');
          maxLbl.className = 'param-edge';
          maxLbl.textContent = def.maxLabel;

          track.appendChild(minLbl);
          track.appendChild(input);
          track.appendChild(maxLbl);

          // Preset ruler (tick marks)
          const ruler = document.createElement('div');
          ruler.className = 'preset-ruler';
          const range = def.max - def.min;
          const allSame = def.presets.simultaneous === def.presets.balanced &&
                          def.presets.balanced === def.presets.natural;
          if (allSame) {
            const pct = ((def.presets.simultaneous - def.min) / range * 100).toFixed(1);
            const dot = document.createElement('span');
            dot.className = 'preset-dot s';
            dot.style.left = pct + '%';
            dot.textContent = 'D';
            ruler.appendChild(dot);
          } else {
            [
              { cls: 's', val: def.presets.simultaneous },
              { cls: 'e', val: def.presets.balanced },
              { cls: 'n', val: def.presets.natural }
            ].forEach(({ cls, val }) => {
              const pct = ((val - def.min) / range * 100).toFixed(1);
              const dot = document.createElement('span');
              dot.className = `preset-dot ${cls}`;
              dot.style.left = pct + '%';
              dot.textContent = cls.toUpperCase();
              ruler.appendChild(dot);
            });
          }

          // Tooltip
          const tip = document.createElement('div');
          tip.className = 'param-tip';
          tip.id = `tip_${def.sl}`;
          tip.hidden = true;
          tip.textContent = def.tip;

          row.appendChild(header);
          row.appendChild(track);
          row.appendChild(ruler);
          row.appendChild(tip);
          slidersContainer.appendChild(row);

          // Wire up input event
          input.addEventListener('input', () => {
            const v = parseFloat(input.value);
            valEl.textContent = def.fmt(v);
            def.set(v);
            localStorage.setItem(def.lsKey, v);
            this._checkPresetStatus();
          });
        });

        // Reset button
        document.getElementById('paramsReset').addEventListener('click', () => {
          this._resetToPreset();
        });

        // Export log button
        document.getElementById('exportLogBtn').addEventListener('click', () => {
          window.open('/session-log/csv', '_blank');
        });
      }

      // Sync all slider DOM elements from current live values
      _syncSliders() {
        this._sliderDefs?.forEach(def => {
          const input = document.getElementById(`sl_${def.sl}`);
          const valEl = document.getElementById(`val_${def.sl}`);
          if (!input) return;
          const v = def.get();
          input.value = v;
          valEl.textContent = def.fmt(v);
        });
        this._checkPresetStatus();
      }

      // Load any localStorage overrides on top of the preset values
      _loadSavedParams() {
        this._sliderDefs?.forEach(def => {
          const saved = localStorage.getItem(def.lsKey);
          if (saved !== null) {
            const v = parseFloat(saved);
            if (!isNaN(v)) def.set(v);
          }
        });
        this._syncSliders();
      }

      // Update the preset badge and mini-button active state
      _checkPresetStatus() {
        const badge = document.getElementById('presetBadge');
        // Update mini-button active states
        document.querySelectorAll('.preset-mini').forEach(btn => btn.classList.remove('active'));
        for (const [key, p] of Object.entries(PRESETS)) {
          if (
            this.STT_PAUSE_MS    === p.STT_PAUSE_MS    &&
            this.MICRO_MIN_CHARS === p.MICRO_MIN_CHARS  &&
            this.MICRO_MAX_CHARS === p.MICRO_MAX_CHARS  &&
            this.MICRO_FLUSH_MS  === p.MICRO_FLUSH_MS   &&
            this.MIN_SEND_GAP_MS === p.MIN_SEND_GAP_MS
          ) {
            if (badge) { badge.textContent = p.name; badge.className = 'preset-status-badge matched'; }
            const activeBtn = document.querySelector(`.preset-mini[data-preset="${key}"]`);
            if (activeBtn) activeBtn.classList.add('active');
            return;
          }
        }
        if (badge) { badge.textContent = 'Personalizzato'; badge.className = 'preset-status-badge custom'; }
      }

      // Full reset to a specific preset key (micro-chunking + VAD + TTS)
      _resetToPresetKey(key) {
        const preset = PRESETS[key] || PRESETS.simultaneous;
        this.currentPreset   = key;
        this.STT_PAUSE_MS    = preset.STT_PAUSE_MS;
        this.MICRO_MIN_CHARS = preset.MICRO_MIN_CHARS;
        this.MICRO_MAX_CHARS = preset.MICRO_MAX_CHARS;
        this.MICRO_FLUSH_MS  = preset.MICRO_FLUSH_MS;
        this.MIN_SEND_GAP_MS = preset.MIN_SEND_GAP_MS;
        this.vadThreshold    = VAD_DEFAULTS.threshold;
        this.silDurationMs   = VAD_DEFAULTS.silenceDurationMs;
        this.ttsRate         = 1.0;
        // Re-enable VAD sliders in case they were disabled
        ['sl_vadThr', 'sl_silDur'].forEach(id => {
          const el = document.getElementById(id);
          if (el) el.disabled = false;
        });
        this._sliderDefs?.forEach(def => localStorage.removeItem(def.lsKey));
        this._syncSliders();
        if (this.isRunning) { this.sendVADUpdate(); this._sendTTSRate(this.ttsRate); }
      }

      // Reset all params to the currently selected preset defaults
      _resetToPreset() {
        this._resetToPresetKey(this.currentPreset);
      }

      // Debounced VAD update (avoids spamming session.update while dragging)
      _scheduleVADUpdate() {
        if (this._vadTimer) clearTimeout(this._vadTimer);
        this._vadTimer = setTimeout(() => {
          this._vadTimer = null;
          this.sendVADUpdate();
        }, 300);
      }

      // Send session.update to OpenAI to change VAD params without restarting.
      // Tries SDK transport.sendEvent() first, falls back to raw dataChannel.
      sendVADUpdate() {
        const transport = this.session?.transport;
        if (!transport) return;

        const payload = {
          type: 'session.update',
          session: {
            turn_detection: {
              type: 'server_vad',
              threshold: Math.round(this.vadThreshold * 100) / 100,
              silence_duration_ms: Math.round(this.silDurationMs)
            }
          }
        };

        let sent = false;

        // Try 1: SDK transport.sendEvent()
        try {
          transport.sendEvent(payload);
          sent = true;
          console.log('[Guide] VAD updated via transport.sendEvent()');
        } catch (e) {
          console.warn('[Guide] transport.sendEvent() failed:', e.message);
        }

        // Try 2: direct WebRTC dataChannel
        if (!sent) {
          const dc = transport._dc || transport.dataChannel || transport._dataChannel;
          if (dc?.readyState === 'open') {
            try {
              dc.send(JSON.stringify(payload));
              sent = true;
              console.log('[Guide] VAD updated via dataChannel.send()');
            } catch (e) {
              console.warn('[Guide] dataChannel.send() failed:', e.message);
            }
          }
        }

        if (!sent) {
          this._disableVADSliders();
          return;
        }

        // Arm 2-second ack timeout ‚Äî expect session.updated event in response
        this._pendingVADUpdate = true;
        if (this._vadAckTimeout) clearTimeout(this._vadAckTimeout);
        this._vadAckTimeout = setTimeout(() => {
          if (!this._pendingVADUpdate) return;
          console.warn('[Guide] session.updated not received within 2s');
          const badge = document.getElementById('vadBadge');
          if (badge) {
            badge.textContent = '‚ö†Ô∏è no ack';
            badge.classList.add('visible');
            setTimeout(() => {
              badge.classList.remove('visible');
              badge.textContent = '‚úì inviato';
            }, 3000);
          }
        }, 2000);

        // Show confirmation badge immediately
        const badge = document.getElementById('vadBadge');
        if (badge) {
          badge.classList.add('visible');
          setTimeout(() => badge.classList.remove('visible'), 2000);
        }
      }

      _disableVADSliders() {
        ['sl_vadThr', 'sl_silDur'].forEach(id => {
          const el = document.getElementById(id);
          if (el) el.disabled = true;
        });
        const badge = document.getElementById('vadBadge');
        if (badge) { badge.textContent = '‚ö†Ô∏è n/d'; badge.classList.add('visible'); }
        console.warn('[Guide] VAD parameters cannot be modified during active session');
      }

      // Push TTS rate to visitor(s) via server broadcast
      _sendTTSRate(rate) {
        if (!this.isRunning) return;
        fetch('/visitor-settings', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ lang: this.targetLanguage, ttsRate: rate })
        }).catch(e => console.warn('[Guide] TTS rate push failed:', e.message));
      }

      // ==========================================
      // EXTENDED STATS
      // ==========================================

      _startExtStats() {
        this._statsInterval = setInterval(() => {
          const bufEl = document.getElementById('bufferLen');
          const wpmEl = document.getElementById('wordsPerMin');
          const timerEl = document.getElementById('sessionTimer');
          if (!bufEl || !wpmEl || !timerEl) return;

          // Buffer length
          bufEl.textContent = (this.microBuffer?.length || 0) + 'c';

          // Words/min (rolling last 60s)
          const now = Date.now();
          this.wordEvents = (this.wordEvents || []).filter(e => now - e.time < 60000);
          const totalWords = this.wordEvents.reduce((s, e) => s + e.count, 0);
          const elapsedMin = (now - this.sessionStartTime) / 60000;
          wpmEl.textContent = elapsedMin > 0.05
            ? Math.round(totalWords / Math.max(elapsedMin, 1))
            : '‚Äî';

          // Session timer mm:ss
          const secs = Math.floor((now - this.sessionStartTime) / 1000);
          const mm = String(Math.floor(secs / 60)).padStart(2, '0');
          const ss = String(secs % 60).padStart(2, '0');
          timerEl.textContent = `${mm}:${ss}`;
        }, 500);
      }

      // ==========================================
      // SESSION LIFECYCLE
      // ==========================================

      async start() {
        try {
          this.targetLanguage = this.targetLanguageSelect.value;

          const selectedPreset = document.querySelector('input[name="preset"]:checked')?.value || 'simultaneous';
          this.applyPreset(selectedPreset);

          // Load any saved param overrides from localStorage
          this._loadSavedParams();

          this.startBtn.disabled = true;
          this.updateStatus('connecting', '‚è≥ Connessione...');

          // Pre-acquire microphone with anti-noise constraints
          const selectedMic = this.micSelect?.value;
          const audioConstraints = {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          };
          if (selectedMic) audioConstraints.deviceId = { exact: selectedMic };
          try {
            this.micStream = await navigator.mediaDevices.getUserMedia({ audio: audioConstraints });
            console.log('[Guide] Pre-acquired mic:', this.micStream.getAudioTracks()[0]?.label);
          } catch (e) {
            console.warn('[Guide] Could not pre-acquire mic:', e);
            this.micStream = null;
          }

          const tokenResponse = await fetch('/api/realtime/token', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ language: this.targetLanguage, mode: 'stt-only' })
          });

          if (!tokenResponse.ok) throw new Error('Failed to get token');

          const { token } = await tokenResponse.json();
          console.log('[Guide] Token received');

          this.agent = new RealtimeAgent({
            name: 'GuideSTT',
            instructions: 'You are a speech-to-text transcriber. Just listen.'
          });

          // Pass our pre-acquired stream to prevent the SDK calling getUserMedia again
          const transport = new OpenAIRealtimeWebRTC({
            mediaStream: this.micStream || undefined
          });

          const sessionConfig = {
            model: 'gpt-4o-realtime-preview-2024-12-17',
            inputAudioTranscription: { model: 'whisper-1' },
            transport,
            config: {
              turnDetection: {
                type: 'server_vad',
                threshold: this.vadThreshold,
                prefixPaddingMs: 300,
                silenceDurationMs: this.silDurationMs,
                createResponse: false,
                interruptResponse: false
              }
            }
          };

          this.session = new RealtimeSession(this.agent, sessionConfig);
          this.setupEventHandlers();

          // Detect unexpected WebRTC drops and surface them to the guide
          transport.on('connection_change', (status) => {
            console.log('[Guide] WebRTC connection_change:', status);
            if ((status === 'disconnected' || status === 'failed') && this.isRunning) {
              console.warn('[Guide] Connessione WebRTC persa inaspettatamente');
              this.stop();
            }
          });

          await this.session.connect({ apiKey: token });
          console.log('[Guide] Connected to OpenAI Realtime API (STT mode)');

          this.muteAllAudio();
          this.muteInterval = setInterval(() => this.muteAllAudio(), 500);

          this.updateStatus('active', '‚úÖ Attivo - Parla nel microfono');
          this.setupForm.classList.add('hidden');
          this.activeSession.classList.remove('hidden');
          this.isRunning = true;

          // Re-enable VAD sliders (may have been disabled by _disableVADSliders in previous session)
          ['sl_vadThr', 'sl_silDur'].forEach(id => {
            const el = document.getElementById(id);
            if (el) el.disabled = false;
          });
          const vadBadgeEl = document.getElementById('vadBadge');
          if (vadBadgeEl) { vadBadgeEl.textContent = '‚úì inviato'; vadBadgeEl.classList.remove('visible'); }

          // Start extended stats (buffer, words/min, session timer)
          this.sessionStartTime = Date.now();
          this.wordEvents = [];
          this._startExtStats();

          await this.requestWakeLock();

          this.lastSttActivityTime = Date.now();
          if (this.sttPauseInterval) clearInterval(this.sttPauseInterval);
          this.sttPauseInterval = setInterval(() => {
            const silenceMs = Date.now() - this.lastSttActivityTime;
            if (silenceMs > this.STT_PAUSE_MS && this.microBuffer.trim().length > 0) {
              this.flushMicroBuffer('stt_pause');
            }
          }, 100);

        } catch (error) {
          console.error('[Guide] Error:', error);
          this.updateStatus('inactive', '‚ùå Errore: ' + error.message);
          this.startBtn.disabled = false;
          alert('Errore nella connessione. Riprova.');
        }
      }

      async stop() {
        if (!this.isRunning) return;
        this.isRunning = false;
        console.log('[Guide] Stopping session...');

        if (this._vadTimer)      { clearTimeout(this._vadTimer);      this._vadTimer      = null; }
        if (this._vadAckTimeout) { clearTimeout(this._vadAckTimeout); this._vadAckTimeout = null; }
        this._pendingVADUpdate = false;
        if (this._statsInterval) { clearInterval(this._statsInterval); this._statsInterval = null; }
        if (this.microFlushTimer)   { clearTimeout(this.microFlushTimer);   this.microFlushTimer = null; }
        if (this.speechStoppedTimer){ clearTimeout(this.speechStoppedTimer); this.speechStoppedTimer = null; }
        if (this.sttPauseInterval)  { clearInterval(this.sttPauseInterval); this.sttPauseInterval = null; }
        if (this.muteInterval)      { clearInterval(this.muteInterval);     this.muteInterval = null; }
        this.microBuffer = '';

        if (this.session) {
          try {
            const disconnectFn = (this.session.disconnect || this.session.close)?.bind(this.session);
            if (disconnectFn) {
              await Promise.race([
                disconnectFn(),
                new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 5000))
              ]);
            }
          } catch (err) {
            console.warn('[Guide] Disconnect failed or timed out:', err.message);
          }
          this.session = null;
          this.agent   = null;
        }

        if (this.micStream) {
          this.micStream.getTracks().forEach(t => {
            t.stop();
            console.log('[Guide] Mic track stopped:', t.label);
          });
          this.micStream = null;
        }

        await this.releaseWakeLock();

        this.setupForm.classList.remove('hidden');
        this.activeSession.classList.add('hidden');
        this.startBtn.disabled = false;
        this.chunksSent = 0;
        this.sequenceNumber = 0;
        this.updateStatus('inactive', 'Terminato');
        this.transcriptLog.innerHTML = '';
        console.log('[Guide] Session stopped');
      }

      setupEventHandlers() {
        if (!this.session) return;

        this.session.on('transport_event', (event) => {
          if (event.type?.includes('transcription') || event.type?.includes('speech')) {
            console.log('[Guide Event]', event.type, JSON.stringify(event).substring(0, 200));
          }

          switch (event.type) {
            case 'input_audio_buffer.speech_started':
              console.log('[Guide] üé§ Speech detected');
              this.lastSttActivityTime = Date.now();
              this.updateStatus('listening', 'üé§ Rilevata voce...');
              break;

            case 'input_audio_buffer.speech_stopped':
              console.log('[Guide] Speech stopped, waiting for transcription...');
              this.updateStatus('active', 'üîÑ Trascrizione...');
              if (this.speechStoppedTimer) clearTimeout(this.speechStoppedTimer);
              this.speechStoppedTimer = setTimeout(() => {
                this.flushMicroBuffer('speech_stopped_delayed');
              }, 300);
              break;

            case 'conversation.item.input_audio_transcription.delta': {
              const rawDelta = event.delta || '';
              const deltaText = rawDelta.trim();
              if (deltaText) {
                this.lastSttActivityTime = Date.now();
                this.gotDelta = true;
                console.log('[Guide] üìù STT delta:', deltaText);
                this.microBuffer = (this.microBuffer || '') + rawDelta;
                if (this.microBuffer.length >= this.MICRO_MAX_CHARS) {
                  this.flushMicroBuffer('delta_max');
                } else {
                  this.scheduleMicroFlush();
                }
              }
              break;
            }

            case 'conversation.item.input_audio_transcription.completed': {
              this.lastSttActivityTime = Date.now();
              const itText = (event.transcript || '').trim();
              console.log('[Guide] üìù STT completed:', itText);

              if (this.gotDelta) {
                this.gotDelta = false;
                if (/[.!?]$/.test(itText) && this.microBuffer) {
                  this.flushMicroBuffer('punct_after_delta');
                }
              } else if (itText) {
                this.microBuffer = (this.microBuffer ? (this.microBuffer + ' ') : '') + itText;
                const endsStrong = /[.!?]$/.test(itText);
                if (endsStrong || this.microBuffer.length >= this.MICRO_MAX_CHARS) {
                  this.flushMicroBuffer(endsStrong ? 'punct' : 'max_chars');
                } else {
                  this.scheduleMicroFlush();
                }
              }

              this.updateStatus('active', '‚úÖ Pronto');
              break;
            }

            case 'session.updated':
              // VAD session.update was acknowledged by the server
              this._pendingVADUpdate = false;
              if (this._vadAckTimeout) { clearTimeout(this._vadAckTimeout); this._vadAckTimeout = null; }
              console.log('[Guide] ‚úÖ session.updated ack received');
              break;

            case 'error':
              console.error('[Guide] ‚ùå Error:', event.error);
              break;
          }
        });
      }

      // ==========================================
      // MICRO-CHUNKING FUNCTIONS
      // ==========================================

      scheduleMicroFlush() {
        if (this.microFlushTimer) clearTimeout(this.microFlushTimer);
        this.microFlushTimer = setTimeout(() => {
          this.flushMicroBuffer('timer');
        }, this.MICRO_FLUSH_MS);
      }

      splitIntoMicroChunks(text) {
        const parts = text
          .replace(/\s+/g, ' ')
          .split(/(?<=[\.\!\?\:\;])\s+/)
          .map(s => s.trim())
          .filter(Boolean);
        return parts;
      }

      flushMicroBuffer(reason = 'manual') {
        const buf = (this.microBuffer || '').trim();
        if (!buf) return;

        const endsStrong = /[.!?]$/.test(buf);
        if (!endsStrong && buf.length < this.MICRO_MIN_CHARS) {
          this.scheduleMicroFlush();
          return;
        }

        const badEnding = /\b(e|ma|perch√©|quindi|che|di|a|da|in|con|su|per|tra|fra|un|una|il|lo|la|i|gli|le|al|del|nel|the|and|but|or|to|of)\s*$/i;
        if (!endsStrong && badEnding.test(buf) && buf.length < this.MICRO_MAX_CHARS) {
          console.log('[Guide] Bad ending, waiting for more text');
          this.scheduleMicroFlush();
          return;
        }

        const chunks = this.splitIntoMicroChunks(buf);
        const toSend = chunks.length === 0 ? [buf] : chunks.filter(c => c.length >= 1);
        // Pre-assign sequence numbers NOW, before any async/timeout, to guarantee strict ordering
        const numberedChunks = toSend.map(text => ({ text, seq: ++this.sequenceNumber }));
        for (const nc of numberedChunks) {
          this.sendSourceText(nc.text, nc.seq);
        }

        this.microBuffer = '';
        if (this.microFlushTimer)    { clearTimeout(this.microFlushTimer);    this.microFlushTimer = null; }
        if (this.speechStoppedTimer) { clearTimeout(this.speechStoppedTimer); this.speechStoppedTimer = null; }

        console.log(`[Guide] Micro flush (${reason}): ${chunks.length} chunk(s)`);
      }

      sendSourceText(sourceText, preAssignedSeq = null) {
        if (!sourceText) return;

        const normalized = sourceText.replace(/\s+/g, ' ').trim().toLowerCase();
        if (normalized && normalized === this.lastSentText && (Date.now() - this.lastSentAt) < 2500) {
          console.log('[Guide] Dedup skip:', sourceText.substring(0, 30) + '...');
          return;
        }

        const seq = preAssignedSeq ?? ++this.sequenceNumber;
        this._sendQueue.push({ sourceText, seq, ts: Date.now() });
        this._processSendQueue();
      }

      async _processSendQueue() {
        if (this._sendProcessing || this._sendQueue.length === 0) return;
        this._sendProcessing = true;

        while (this._sendQueue.length > 0) {
          const { sourceText, seq, ts } = this._sendQueue.shift();

          // Anti-burst: wait if needed before sending
          const gap = Date.now() - this.lastSendAt;
          if (gap < this.MIN_SEND_GAP_MS) {
            await new Promise(r => setTimeout(r, this.MIN_SEND_GAP_MS - gap));
          }

          const now = Date.now();
          const normalized = sourceText.replace(/\s+/g, ' ').trim().toLowerCase();
          // Re-check dedup at send time in case a duplicate slipped through
          if (normalized && normalized === this.lastSentText && (now - this.lastSentAt) < 2500) {
            console.log('[Guide] Dedup skip (queue):', sourceText.substring(0, 30) + '...');
            continue;
          }

          this.lastSentText = normalized;
          this.lastSentAt   = now;
          this.lastSendAt   = now;

          const chunk = {
            lang: this.targetLanguage,
            sourceLang: 'it',
            sourceText,
            ts,
            seq
          };

          console.log(`[Guide] Sending chunk #${chunk.seq} ‚Üí ${chunk.lang}:`, sourceText);

          try {
            const sentAt = Date.now();
            const result = await this.sendWithRetry(chunk);

            if (result) {
              const latency = Date.now() - sentAt;
              this.chunkLatencies.push(latency);
              if (this.chunkLatencies.length > 5) this.chunkLatencies.shift();
              const avg = this.chunkLatencies.reduce((a, b) => a + b, 0) / this.chunkLatencies.length;
              this.latencyDisplayEl.textContent = `~${(avg / 1000).toFixed(1)}s`;

              this.chunksSent++;
              this.chunksSentEl.textContent = this.chunksSent;

              // Track word count for words/min stat
              const wordCount = sourceText.trim().split(/\s+/).filter(Boolean).length;
              this.wordEvents = (this.wordEvents || []);
              this.wordEvents.push({ count: wordCount, time: Date.now() });

              this.updateReceiverStatus(result.hasReceiver ? (result.accepted ? 'ok' : 'mismatch') : 'offline');

              if (result.suggestedPreset && result.suggestedPreset !== this.currentPreset) {
                console.log(`[Guide] Visitor suggests preset: ${result.suggestedPreset}`);
                this.applyPreset(result.suggestedPreset);
                this._syncSliders();
                const radio = document.querySelector(`input[name="preset"][value="${result.suggestedPreset}"]`);
                if (radio) radio.checked = true;
              }

              this.addToTranscript(sourceText);
              console.log(`[Guide] Sent. latency=${latency}ms hasReceiver=${result.hasReceiver}`);
            } else {
              this.updateReceiverStatus('error');
            }
          } catch (err) {
            console.error('[Guide] sendSourceText error:', err);
            this.updateReceiverStatus('error');
          }
        }

        this._sendProcessing = false;
      }

      updateReceiverStatus(status) {
        const icons = { ok: 'üü¢', mismatch: 'üü†', offline: 'üî¥', error: 'üî¥' };
        this.receiverStatusEl.textContent = icons[status] || 'üî¥';
      }

      async sendWithRetry(chunk, maxRetries = 3) {
        let delay = 1000;
        for (let i = 0; i < maxRetries; i++) {
          try {
            const response = await fetch('/ingest', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(chunk)
            });

            if (!response.ok) {
              const text = await response.text();
              console.warn(`[Guide] Server error ${response.status}:`, text.substring(0, 100));
              throw new Error(`HTTP ${response.status}`);
            }

            let result;
            try {
              result = await response.json();
            } catch {
              console.warn('[Guide] Risposta non-JSON dal server, assumo ok');
              result = { ok: true };
            }

            if (result.ok) return result;
            console.warn('[Guide] Chunk not accepted:', result);
            return null;
          } catch (err) {
            console.warn(`[Guide] Retry ${i + 1}/${maxRetries} dopo ${delay}ms:`, err.message);
            if (i < maxRetries - 1) {
              await new Promise(r => setTimeout(r, delay));
              delay *= 2;
            }
          }
        }
        console.error('[Guide] Chunk failed after retries, dropping');
        return null;
      }

      // ==========================================
      // WAKE LOCK
      // ==========================================

      async requestWakeLock() {
        if (!('wakeLock' in navigator)) return;
        try {
          this.wakeLock = await navigator.wakeLock.request('screen');
          this.wakeLockBadge.style.display = '';
          this.wakeLock.addEventListener('release', () => {
            this.wakeLockBadge.style.display = 'none';
            this.wakeLock = null;
          });
          console.log('[Guide] Wake lock acquired');
        } catch (e) {
          console.warn('[Guide] Wake lock failed:', e);
        }
      }

      async releaseWakeLock() {
        if (this.wakeLock) {
          try { await this.wakeLock.release(); } catch { /* already released */ }
          this.wakeLock = null;
          this.wakeLockBadge.style.display = 'none';
        }
      }

      // ==========================================
      // MICROPHONE SELECTION
      // ==========================================

      async enumerateMics() {
        try {
          const tempStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          tempStream.getTracks().forEach(t => t.stop());

          const devices = await navigator.mediaDevices.enumerateDevices();
          const mics    = devices.filter(d => d.kind === 'audioinput');
          const saved   = localStorage.getItem('voicetranslator_mic');

          this.micSelect.innerHTML = '<option value="">Default del sistema</option>';
          mics.forEach(mic => {
            const opt = document.createElement('option');
            opt.value = mic.deviceId;
            opt.textContent = mic.label || `Microfono ${mic.deviceId.substring(0, 8)}`;
            if (saved && saved === mic.deviceId) opt.selected = true;
            this.micSelect.appendChild(opt);
          });

          this.micSelect.onchange = () => {
            localStorage.setItem('voicetranslator_mic', this.micSelect.value);
          };

          console.log(`[Guide] Found ${mics.length} microphone(s)`);
        } catch (e) {
          console.warn('[Guide] Could not enumerate mics:', e);
        }
      }

      addToTranscript(text) {
        const p = document.createElement('p');
        p.textContent = text;
        this.transcriptLog.prepend(p);
        while (this.transcriptLog.children.length > 10) {
          this.transcriptLog.removeChild(this.transcriptLog.lastChild);
        }
      }

      updateStatus(state, text) {
        this.status.className  = 'status ' + state;
        this.status.textContent = text;
      }

      muteAllAudio() {
        document.querySelectorAll('audio').forEach(audio => {
          audio.volume = 0;
          audio.muted  = true;
          audio.pause();
        });
      }
    }

    // Initialize
    const guide = new GuideInput();
  </script>
</body>
</html>
