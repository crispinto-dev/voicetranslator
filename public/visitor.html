<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ricevitore - Dual Device Mode</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }

    .container {
      background: white;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      padding: 40px;
      max-width: 600px;
      width: 100%;
    }

    h1 {
      color: #333;
      margin-bottom: 10px;
      font-size: 28px;
      text-align: center;
    }

    .subtitle {
      color: #666;
      text-align: center;
      margin-bottom: 30px;
      font-size: 14px;
    }

    .info-box {
      background: #d1fae5;
      border-left: 4px solid #10b981;
      padding: 15px;
      margin-bottom: 25px;
      border-radius: 8px;
      font-size: 13px;
      color: #065f46;
      line-height: 1.6;
    }

    .form-group {
      margin-bottom: 20px;
    }

    label {
      display: block;
      color: #555;
      font-weight: 500;
      margin-bottom: 8px;
      font-size: 14px;
    }

    select {
      width: 100%;
      padding: 12px 16px;
      border: 2px solid #e0e0e0;
      border-radius: 10px;
      font-size: 16px;
      background: white;
    }

    select:focus {
      outline: none;
      border-color: #10b981;
    }

    .controls {
      display: flex;
      gap: 10px;
    }

    .btn {
      flex: 1;
      padding: 14px;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }

    .btn-primary {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
    }

    .btn-primary:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
    }

    .btn-primary:disabled {
      background: #d1d5db;
      cursor: not-allowed;
    }

    .btn-danger {
      background: #ef4444;
      color: white;
    }

    .btn-danger:hover {
      background: #dc2626;
    }

    .status {
      text-align: center;
      padding: 12px;
      border-radius: 10px;
      margin-top: 20px;
      font-size: 14px;
      font-weight: 500;
    }

    .status.inactive  { background: #f3f4f6; color: #6b7280; }
    .status.connecting{ background: #fef3c7; color: #92400e; }
    .status.connected { background: #d1fae5; color: #065f46; }
    .status.speaking  { background: #dbeafe; color: #1e40af; }

    /* ---- Params panel ---- */
    .params-panel {
      margin-top: 16px;
      border: 1px solid #d1fae5;
      border-radius: 10px;
      overflow: hidden;
    }

    .params-toggle {
      width: 100%;
      background: #f0fdf4;
      border: none;
      padding: 10px 14px;
      text-align: left;
      font-size: 13px;
      font-weight: 600;
      color: #065f46;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .params-toggle::after { content: '‚ñº'; transition: transform 0.2s; font-size: 11px; }
    .params-toggle.open::after { transform: rotate(180deg); }

    .params-body {
      display: none;
      padding: 12px 14px;
      background: white;
    }

    .params-body.open { display: block; }

    .param-row {
      display: grid;
      grid-template-columns: 1fr 110px 42px;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
    }

    .param-row:last-child { margin-bottom: 0; }

    .param-label { font-size: 12px; color: #374151; }

    .param-slider {
      -webkit-appearance: none;
      height: 4px;
      border-radius: 2px;
      background: #d1fae5;
      outline: none;
      cursor: pointer;
    }

    .param-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #10b981;
      cursor: pointer;
    }

    .param-value {
      font-size: 12px;
      font-weight: 600;
      color: #10b981;
      text-align: right;
      white-space: nowrap;
    }

    /* ---- Subtitle box ---- */
    .subtitle-box {
      display: none;
      margin-top: 16px;
      padding: 14px 16px;
      background: #eff6ff;
      border-left: 4px solid #3b82f6;
      border-radius: 8px;
      font-size: 15px;
      color: #1e3a8a;
      line-height: 1.5;
      min-height: 48px;
      font-style: italic;
    }

    .subtitle-box.active { display: block; }

    /* ---- Stats ---- */
    .stats {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
      margin-top: 20px;
    }

    .stat-box {
      background: #f9fafb;
      padding: 12px;
      border-radius: 8px;
      text-align: center;
    }

    .stat-label {
      font-size: 11px;
      color: #6b7280;
      text-transform: uppercase;
      margin-bottom: 5px;
    }

    .stat-value {
      font-size: 20px;
      font-weight: 600;
      color: #10b981;
    }

    .stat-value.latency { font-size: 15px; }

    /* ---- Transcript ---- */
    .transcript {
      margin-top: 20px;
      padding: 15px;
      background: #f9fafb;
      border-radius: 10px;
      max-height: 250px;
      overflow-y: auto;
    }

    .transcript h3 {
      font-size: 12px;
      color: #6b7280;
      margin-bottom: 10px;
      text-transform: uppercase;
    }

    .transcript p {
      font-size: 13px;
      color: #333;
      line-height: 1.6;
      margin: 5px 0;
      padding: 8px;
      background: white;
      border-radius: 6px;
    }

    .wake-lock-badge {
      text-align: center;
      font-size: 12px;
      color: #065f46;
      background: #d1fae5;
      padding: 6px 12px;
      border-radius: 8px;
      margin-top: 10px;
    }

    .warning {
      background: #fef3c7;
      border-left: 4px solid #f59e0b;
      padding: 12px;
      margin-top: 15px;
      border-radius: 8px;
      font-size: 12px;
      color: #92400e;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üîä Ricevitore - Output</h1>
    <p class="subtitle">Dual Device Mode - Device Ricevitore</p>

    <div class="info-box">
      <strong>üìå Connessione Audio:</strong><br>
      Collega le cuffie/speaker di questo device allo splitter audio.
      I visitatori ascolteranno dallo splitter.
    </div>

    <div class="form-group">
      <label for="lang">üåç Lingua Audio:</label>
      <select id="lang">
        <option value="en">English</option>
        <option value="es">Espa√±ol</option>
        <option value="fr">Fran√ßais</option>
        <option value="de">Deutsch</option>
        <option value="pt">Portugu√™s</option>
        <option value="zh">‰∏≠Êñá</option>
        <option value="ja">Êó•Êú¨Ë™û</option>
        <option value="ko">ÌïúÍµ≠Ïñ¥</option>
        <option value="ar">ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</option>
        <option value="ru">–†—É—Å—Å–∫–∏–π</option>
      </select>
    </div>

    <div class="controls">
      <button class="btn btn-primary" id="start">‚ñ∂ Avvia</button>
      <button class="btn btn-danger" id="stop">‚èπ Stop</button>
    </div>

    <div class="status inactive" id="status">Pronto</div>
    <div class="wake-lock-badge" id="wakeLockBadge" style="display:none">üîí Schermo attivo</div>

    <!-- TTS parameters panel -->
    <div class="params-panel">
      <button class="params-toggle" id="paramsToggle">‚öôÔ∏è Parametri TTS</button>
      <div class="params-body" id="paramsBody">
        <div class="param-row">
          <span class="param-label">Velocit√† (rate)</span>
          <input type="range" class="param-slider" id="slTtsRate" min="0.5" max="2.0" step="0.1" value="1.0">
          <span class="param-value" id="valTtsRate">1.0x</span>
        </div>
        <div class="param-row">
          <span class="param-label">Tono (pitch)</span>
          <input type="range" class="param-slider" id="slTtsPitch" min="0.5" max="2.0" step="0.1" value="1.0">
          <span class="param-value" id="valTtsPitch">1.0x</span>
        </div>
      </div>
    </div>

    <!-- Real-time subtitle of the currently speaking utterance -->
    <div class="subtitle-box" id="subtitleBox"></div>

    <div class="stats">
      <div class="stat-box">
        <div class="stat-label">Chunk Ricevuti</div>
        <div class="stat-value" id="chunksReceived">0</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">In Coda</div>
        <div class="stat-value" id="queueSize">0</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">Latenza</div>
        <div class="stat-value latency" id="latencyMs">‚Äî</div>
      </div>
    </div>

    <div class="transcript">
      <h3>Testo Ricevuto</h3>
      <div id="transcriptLog"></div>
    </div>

    <div class="warning">
      ‚ö†Ô∏è Assicurati che la guida abbia avviato /guide-input.html
    </div>

    <div id="noChunkWarning" style="display:none; color:#92400e; padding:10px; background:#fef3c7; border-left:4px solid #f59e0b; border-radius:8px; font-size:13px; margin-top:10px;">
      ‚ö†Ô∏è Nessun audio ricevuto negli ultimi 15 secondi. Verificare che la guida stia parlando.
    </div>
  </div>

  <script>
    let es = null;
    let queue = [];        // Array of { text, ts }
    let speaking = false;
    let preferredVoice = null;
    let chunksReceived = 0;
    let speakingStartedAt = 0;
    let ttsWatchdog = null;
    let wakeLock = null;
    let lastLatencyMs = null;

    // TTS params ‚Äî persisted in localStorage
    let ttsRate  = parseFloat(localStorage.getItem('vp_ttsRate')  || '1.0');
    let ttsPitch = parseFloat(localStorage.getItem('vp_ttsPitch') || '1.0');

    // Dynamic TTS watchdog based on text length (8‚Äì15 s margin)
    function getWatchdogTimeout(text) {
      const estimatedDuration = (text.length / 50) * 1000; // ~50 chars/sec spoken
      return Math.min(15000, Math.max(8000, estimatedDuration + 4000));
    }

    let currentLang = 'en';
    let lastProcessedSeq = -1;
    let pendingChunks = new Map();
    let backlogInterval = null;
    let lastChunkTime = Date.now();
    let noChunkInterval = null;
    let pendingTimer = null;

    // ---- DOM refs ----
    const statusEl         = document.getElementById('status');
    const transcriptLog    = document.getElementById('transcriptLog');
    const chunksReceivedEl = document.getElementById('chunksReceived');
    const queueSizeEl      = document.getElementById('queueSize');
    const latencyEl        = document.getElementById('latencyMs');
    const subtitleBox      = document.getElementById('subtitleBox');

    // ---- Params panel ----
    const paramsToggle = document.getElementById('paramsToggle');
    const paramsBody   = document.getElementById('paramsBody');
    const slTtsRate    = document.getElementById('slTtsRate');
    const valTtsRate   = document.getElementById('valTtsRate');
    const slTtsPitch   = document.getElementById('slTtsPitch');
    const valTtsPitch  = document.getElementById('valTtsPitch');

    // Restore slider positions from localStorage
    slTtsRate.value  = ttsRate;
    valTtsRate.textContent  = ttsRate.toFixed(1) + 'x';
    slTtsPitch.value = ttsPitch;
    valTtsPitch.textContent = ttsPitch.toFixed(1) + 'x';

    paramsToggle.onclick = () => {
      paramsToggle.classList.toggle('open');
      paramsBody.classList.toggle('open');
    };

    slTtsRate.oninput = () => {
      ttsRate = parseFloat(slTtsRate.value);
      valTtsRate.textContent = ttsRate.toFixed(1) + 'x';
      localStorage.setItem('vp_ttsRate', ttsRate);
    };

    slTtsPitch.oninput = () => {
      ttsPitch = parseFloat(slTtsPitch.value);
      valTtsPitch.textContent = ttsPitch.toFixed(1) + 'x';
      localStorage.setItem('vp_ttsPitch', ttsPitch);
    };

    // ---- Wake Lock ----
    async function requestWakeLock() {
      if (!('wakeLock' in navigator)) {
        console.warn('[Visitor] Wake Lock API not supported');
        return;
      }
      try {
        wakeLock = await navigator.wakeLock.request('screen');
        document.getElementById('wakeLockBadge').style.display = '';
        wakeLock.addEventListener('release', () => {
          document.getElementById('wakeLockBadge').style.display = 'none';
          wakeLock = null;
        });
        console.log('[Visitor] Wake lock acquired');
      } catch (e) {
        console.warn('[Visitor] Wake lock failed:', e);
      }
    }

    async function releaseWakeLock() {
      if (wakeLock) {
        try { await wakeLock.release(); } catch (_e) { /* already released */ }
        wakeLock = null;
        document.getElementById('wakeLockBadge').style.display = 'none';
      }
    }

    document.addEventListener('visibilitychange', async () => {
      if (document.visibilityState === 'visible' && es && !wakeLock) {
        await requestWakeLock();
      }
    });

    // ---- UI helpers ----
    function setStatus(className, text) {
      statusEl.className = 'status ' + className;
      statusEl.textContent = text;
    }

    function addTranscript(text) {
      const p = document.createElement('p');
      p.textContent = text;
      transcriptLog.prepend(p);
      while (transcriptLog.children.length > 15) {
        transcriptLog.removeChild(transcriptLog.lastChild);
      }
    }

    function updateStats() {
      chunksReceivedEl.textContent = chunksReceived;
      queueSizeEl.textContent = queue.length + (speaking ? 1 : 0);
      latencyEl.textContent = lastLatencyMs != null ? lastLatencyMs + 'ms' : '‚Äî';
    }

    function showSubtitle(text) {
      subtitleBox.textContent = text;
      subtitleBox.classList.add('active');
    }

    function hideSubtitle() {
      subtitleBox.textContent = '';
      subtitleBox.classList.remove('active');
    }

    function showNoChunkWarning() {
      document.getElementById('noChunkWarning').style.display = 'block';
    }

    function hideNoChunkWarning() {
      document.getElementById('noChunkWarning').style.display = 'none';
    }

    // ==========================================
    // CHUNK SEQUENCE ORDERING
    // ==========================================

    function processChunk(data) {
      const { text, seq, ts } = data;

      if (seq <= lastProcessedSeq) {
        console.log('[Visitor] Chunk duplicato scartato:', seq);
        return;
      }

      if (seq === lastProcessedSeq + 1) {
        enqueueAndSpeak(text, ts, currentLang);
        lastProcessedSeq = seq;
        processPendingInOrder();
      } else {
        pendingChunks.set(seq, { text, ts, receivedAt: Date.now() });
        console.log(`[Visitor] Chunk #${seq} fuori ordine, in attesa (ultimo: ${lastProcessedSeq})`);
        scheduleProcessPending();
      }
    }

    function scheduleProcessPending() {
      if (pendingTimer) return;
      pendingTimer = setTimeout(() => {
        pendingTimer = null;
        const nextExpected = lastProcessedSeq + 1;
        if (pendingChunks.has(nextExpected)) {
          const chunk = pendingChunks.get(nextExpected);
          pendingChunks.delete(nextExpected);
          enqueueAndSpeak(chunk.text, chunk.ts, currentLang);
          lastProcessedSeq = nextExpected;
          if (pendingChunks.size > 0) scheduleProcessPending();
        } else if (pendingChunks.size > 0) {
          const oldest = Math.min(...pendingChunks.keys());
          if (oldest > nextExpected) {
            console.warn('[Visitor] Chunk persi, salto a seq:', oldest - 1);
            lastProcessedSeq = oldest - 1;
            scheduleProcessPending();
          }
        }
      }, 280);
    }

    function processPendingInOrder() {
      while (pendingChunks.has(lastProcessedSeq + 1)) {
        const chunk = pendingChunks.get(lastProcessedSeq + 1);
        pendingChunks.delete(lastProcessedSeq + 1);
        enqueueAndSpeak(chunk.text, chunk.ts, currentLang);
        lastProcessedSeq++;
      }
    }

    // ==========================================
    // AUTO-PRESET ON BACKLOG
    // ==========================================

    function checkBacklogAndAdaptPreset() {
      const estimatedBacklogSeconds = queue.length * 2;
      if (estimatedBacklogSeconds > 6) {
        fetch('/preset-suggest', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ lang: currentLang, preset: 'simultaneous' })
        }).catch(() => {});
      } else if (estimatedBacklogSeconds < 2) {
        fetch('/preset-suggest', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ lang: currentLang, preset: 'natural' })
        }).catch(() => {});
      }
    }

    // ==========================================
    // VOICE SELECTION
    // ==========================================

    function pickVoice(lang) {
      const voices = window.speechSynthesis.getVoices() || [];
      const matching = voices.filter(v => (v.lang || '').toLowerCase().startsWith(lang));
      if (matching.length === 0) return null;

      // Prefer premium local voices (Google/Microsoft/Apple)
      const premiumVoice = matching.find(v =>
        /google|microsoft|apple/i.test(v.name) && v.localService
      );
      if (premiumVoice) return premiumVoice;

      const localVoices = matching.filter(v => v.localService === true);
      if (localVoices.length > 0) return localVoices[0];

      return matching[0];
    }

    async function warmupTTS(lang) {
      return new Promise((resolve) => {
        const tryPick = () => {
          preferredVoice = pickVoice(lang);
          console.log('[Visitor] Selected voice:', preferredVoice?.name || 'default', preferredVoice?.lang || lang);
          resolve();
        };
        window.speechSynthesis.onvoiceschanged = tryPick;
        tryPick();
      });
    }

    // ==========================================
    // TTS ENGINE
    // ==========================================

    function speakNext(lang) {
      if (speaking || queue.length === 0) {
        updateStats();
        return;
      }

      const item = queue.shift();
      const text    = item.text;
      const chunkTs = item.ts;

      const u = new SpeechSynthesisUtterance(text);
      if (preferredVoice) u.voice = preferredVoice;
      u.lang   = preferredVoice?.lang || lang;
      u.rate   = ttsRate;
      u.pitch  = ttsPitch;
      u.volume = 1.0;

      speaking = true;
      speakingStartedAt = Date.now();

      // End-to-end latency: from chunk ingestion timestamp to TTS start
      if (chunkTs) {
        lastLatencyMs = Date.now() - chunkTs;
        console.log(`[Visitor] Latency: ${lastLatencyMs}ms`);
      }

      setStatus('speaking', 'üîä Riproduzione...');
      showSubtitle(text);
      updateStats();

      // Clear any previous watchdog
      if (ttsWatchdog) clearInterval(ttsWatchdog);

      // Watchdog: cancel stalled TTS only when there's a queue backlog
      const watchdogMs = getWatchdogTimeout(text);
      ttsWatchdog = setInterval(() => {
        if (!speaking) { clearInterval(ttsWatchdog); ttsWatchdog = null; return; }
        const elapsed = Date.now() - speakingStartedAt;
        if (elapsed >= watchdogMs && queue.length >= 1) {
          console.warn(`[Visitor] TTS watchdog: elapsed ${elapsed}ms, backlog ${queue.length}, forcing recovery`);
          clearInterval(ttsWatchdog);
          ttsWatchdog = null;
          window.speechSynthesis.cancel();
          speaking = false;
          hideSubtitle();
          speakNext(lang);
        }
      }, 1000);

      u.onend = () => {
        speaking = false;
        if (ttsWatchdog) { clearInterval(ttsWatchdog); ttsWatchdog = null; }
        hideSubtitle();
        setTimeout(() => {
          if (queue.length > 0) {
            speakNext(lang);
          } else {
            setStatus('connected', 'üü¢ Connesso - In ascolto');
          }
        }, 100);
      };

      u.onerror = (e) => {
        console.error('[Visitor] TTS error:', e);
        speaking = false;
        if (ttsWatchdog) { clearInterval(ttsWatchdog); ttsWatchdog = null; }
        hideSubtitle();
        setTimeout(() => speakNext(lang), 100);
      };

      console.log('[Visitor] Speaking:', text.substring(0, 50) + '...');
      window.speechSynthesis.speak(u);
    }

    function enqueueAndSpeak(text, ts, lang) {
      const cleaned = text.trim();
      if (!cleaned) return;

      queue.push({ text: cleaned, ts });

      // If queue too long, merge oldest pairs preserving order and earliest timestamp
      while (queue.length > 10 && queue.length >= 2) {
        const first  = queue.shift();
        const second = queue.shift();
        queue.unshift({ text: first.text + ' ' + second.text, ts: first.ts });
        console.log('[Visitor] Queue merged:', (first.text + ' ' + second.text).substring(0, 50));
      }

      addTranscript(cleaned);
      chunksReceived++;
      updateStats();

      // Micro-delay for first chunk after silence to avoid TTS cuts
      if (!speaking && queue.length === 1) {
        setTimeout(() => speakNext(lang), 40);
      } else if (!speaking) {
        speakNext(lang);
      }
    }

    // ==========================================
    // SSE CONNECTION
    // ==========================================

    function connectSSE(lang) {
      if (es) es.close();

      queue = [];
      speaking = false;
      window.speechSynthesis.cancel();
      hideSubtitle();
      setStatus('connecting', '‚è≥ Connessione...');

      es = new EventSource(`/sse?lang=${lang}`);

      es.addEventListener('hello', () => {
        console.log('[Visitor] Connected to SSE');
        setStatus('connected', 'üü¢ Connesso - In ascolto');
        lastChunkTime = Date.now();
        if (noChunkInterval) clearInterval(noChunkInterval);
        noChunkInterval = setInterval(() => {
          if (es && Date.now() - lastChunkTime > 15000) showNoChunkWarning();
        }, 5000);
      });

      es.addEventListener('ping', () => {
        // Heartbeat ‚Äî keep connection alive
      });

      es.addEventListener('chunk', (ev) => {
        lastChunkTime = Date.now();
        hideNoChunkWarning();
        const data = JSON.parse(ev.data);
        console.log('[Visitor] Received chunk #' + data.seq);
        processChunk(data);
      });

      // Settings pushed by guide (TTS rate) or replayed for late-joining clients
      es.addEventListener('settings', (ev) => {
        const d = JSON.parse(ev.data);
        if (d.ttsRate != null) {
          ttsRate = parseFloat(d.ttsRate);
          localStorage.setItem('vp_ttsRate', ttsRate);
          slTtsRate.value = ttsRate;
          valTtsRate.textContent = ttsRate.toFixed(1) + 'x';
          console.log('[Visitor] TTS rate synced from guide:', ttsRate);
        }
      });

      es.onerror = (e) => {
        console.error('[Visitor] SSE error:', e);
        if (es.readyState === EventSource.CLOSED) {
          setStatus('inactive', 'üî¥ Connessione persa');
          console.log('[Visitor] Connection closed permanently');
        } else {
          setStatus('connecting', 'üîÑ Riconnessione...');
          console.log('[Visitor] EventSource will auto-reconnect...');
        }
      };
    }

    // ==========================================
    // CONTROLS
    // ==========================================

    document.getElementById('start').onclick = async () => {
      const lang = document.getElementById('lang').value;
      currentLang = lang;
      lastProcessedSeq = -1;
      pendingChunks.clear();
      console.log('[Visitor] Starting with language:', lang);

      await warmupTTS(lang);
      connectSSE(lang);
      await requestWakeLock();

      if (backlogInterval) clearInterval(backlogInterval);
      backlogInterval = setInterval(checkBacklogAndAdaptPreset, 5000);

      // iOS workaround: speak silent utterance to unlock audio context
      try {
        const u = new SpeechSynthesisUtterance(' ');
        u.volume = 0;
        window.speechSynthesis.speak(u);
      } catch (e) {
        console.warn('[Visitor] Could not speak silent utterance:', e);
      }
    };

    document.getElementById('stop').onclick = async () => {
      if (es) { es.close(); es = null; }
      queue = [];
      window.speechSynthesis.cancel();
      speaking = false;
      hideSubtitle();
      if (ttsWatchdog)    { clearInterval(ttsWatchdog);    ttsWatchdog    = null; }
      if (backlogInterval){ clearInterval(backlogInterval); backlogInterval = null; }
      if (noChunkInterval){ clearInterval(noChunkInterval); noChunkInterval = null; }
      if (pendingTimer)   { clearTimeout(pendingTimer);     pendingTimer    = null; }
      hideNoChunkWarning();
      lastProcessedSeq = -1;
      pendingChunks.clear();
      await releaseWakeLock();
      setStatus('inactive', '‚èπ Stop');
      chunksReceived = 0;
      lastLatencyMs  = null;
      updateStats();
    };
  </script>
</body>
</html>
