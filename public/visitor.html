<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ricevitore - Dual Device Mode</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }

    .container {
      background: white;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      padding: 40px;
      max-width: 600px;
      width: 100%;
    }

    h1 {
      color: #333;
      margin-bottom: 10px;
      font-size: 28px;
      text-align: center;
    }

    .subtitle {
      color: #666;
      text-align: center;
      margin-bottom: 30px;
      font-size: 14px;
    }

    .info-box {
      background: #d1fae5;
      border-left: 4px solid #10b981;
      padding: 15px;
      margin-bottom: 25px;
      border-radius: 8px;
      font-size: 13px;
      color: #065f46;
      line-height: 1.6;
    }

    .form-group {
      margin-bottom: 20px;
    }

    label {
      display: block;
      color: #555;
      font-weight: 500;
      margin-bottom: 8px;
      font-size: 14px;
    }

    select {
      width: 100%;
      padding: 12px 16px;
      border: 2px solid #e0e0e0;
      border-radius: 10px;
      font-size: 16px;
      background: white;
    }

    select:focus {
      outline: none;
      border-color: #10b981;
    }

    .controls {
      display: flex;
      gap: 10px;
    }

    .btn {
      flex: 1;
      padding: 14px;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }

    .btn-primary {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
    }

    .btn-primary:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
    }

    .btn-primary:disabled {
      background: #d1d5db;
      cursor: not-allowed;
    }

    .btn-danger {
      background: #ef4444;
      color: white;
    }

    .btn-danger:hover {
      background: #dc2626;
    }

    .status {
      text-align: center;
      padding: 12px;
      border-radius: 10px;
      margin-top: 20px;
      font-size: 14px;
      font-weight: 500;
    }

    .status.inactive { background: #f3f4f6; color: #6b7280; }
    .status.connecting { background: #fef3c7; color: #92400e; }
    .status.connected { background: #d1fae5; color: #065f46; }
    .status.speaking { background: #dbeafe; color: #1e40af; }

    .stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 20px;
    }

    .stat-box {
      background: #f9fafb;
      padding: 12px;
      border-radius: 8px;
      text-align: center;
    }

    .stat-label {
      font-size: 11px;
      color: #6b7280;
      text-transform: uppercase;
      margin-bottom: 5px;
    }

    .stat-value {
      font-size: 20px;
      font-weight: 600;
      color: #10b981;
    }

    .transcript {
      margin-top: 20px;
      padding: 15px;
      background: #f9fafb;
      border-radius: 10px;
      max-height: 250px;
      overflow-y: auto;
    }

    .transcript h3 {
      font-size: 12px;
      color: #6b7280;
      margin-bottom: 10px;
      text-transform: uppercase;
    }

    .transcript p {
      font-size: 13px;
      color: #333;
      line-height: 1.6;
      margin: 5px 0;
      padding: 8px;
      background: white;
      border-radius: 6px;
    }

    .wake-lock-badge {
      text-align: center;
      font-size: 12px;
      color: #065f46;
      background: #d1fae5;
      padding: 6px 12px;
      border-radius: 8px;
      margin-top: 10px;
    }

    .warning {
      background: #fef3c7;
      border-left: 4px solid #f59e0b;
      padding: 12px;
      margin-top: 15px;
      border-radius: 8px;
      font-size: 12px;
      color: #92400e;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üîä Ricevitore - Output</h1>
    <p class="subtitle">Dual Device Mode - Device Ricevitore</p>

    <div class="info-box">
      <strong>üìå Connessione Audio:</strong><br>
      Collega le cuffie/speaker di questo device allo splitter audio.
      I visitatori ascolteranno dallo splitter.
    </div>

    <div class="form-group">
      <label for="lang">üåç Lingua Audio:</label>
      <select id="lang">
        <option value="en">English</option>
        <option value="es">Espa√±ol</option>
        <option value="fr">Fran√ßais</option>
        <option value="de">Deutsch</option>
        <option value="pt">Portugu√™s</option>
        <option value="zh">‰∏≠Êñá</option>
        <option value="ja">Êó•Êú¨Ë™û</option>
        <option value="ko">ÌïúÍµ≠Ïñ¥</option>
        <option value="ar">ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</option>
        <option value="ru">–†—É—Å—Å–∫–∏–π</option>
      </select>
    </div>

    <div class="controls">
      <button class="btn btn-primary" id="start">‚ñ∂ Avvia</button>
      <button class="btn btn-danger" id="stop">‚èπ Stop</button>
    </div>

    <div class="status inactive" id="status">Pronto</div>
    <div class="wake-lock-badge" id="wakeLockBadge" style="display:none">üîí Schermo attivo</div>

    <div class="stats">
      <div class="stat-box">
        <div class="stat-label">Chunk Ricevuti</div>
        <div class="stat-value" id="chunksReceived">0</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">In Coda</div>
        <div class="stat-value" id="queueSize">0</div>
      </div>
    </div>

    <div class="transcript">
      <h3>Testo Ricevuto</h3>
      <div id="transcriptLog"></div>
    </div>

    <div class="warning">
      ‚ö†Ô∏è Assicurati che la guida abbia avviato /guide-input.html
    </div>

    <div id="noChunkWarning" style="display:none; color:#92400e; padding:10px; background:#fef3c7; border-left:4px solid #f59e0b; border-radius:8px; font-size:13px; margin-top:10px;">
      ‚ö†Ô∏è Nessun audio ricevuto negli ultimi 15 secondi. Verificare che la guida stia parlando.
    </div>
  </div>

  <script>
    let es = null;
    let queue = [];
    let speaking = false;
    let preferredVoice = null;
    let chunksReceived = 0;
    let speakingStartedAt = 0;
    let ttsWatchdog = null;
    let wakeLock = null;
    // Dynamic TTS watchdog based on text length (8-15s margin)
    function getWatchdogTimeout(text) {
      const estimatedDuration = (text.length / 50) * 1000; // ~50 chars/sec spoken
      return Math.min(15000, Math.max(8000, estimatedDuration + 4000));
    }
    let currentLang = 'en';
    let lastProcessedSeq = -1;
    let pendingChunks = new Map();
    let backlogInterval = null;
    let lastChunkTime = Date.now();
    let noChunkInterval = null;
    let pendingTimer = null;

    // Wake Lock helpers
    async function requestWakeLock() {
      if (!('wakeLock' in navigator)) {
        console.warn('[Visitor] Wake Lock API not supported');
        return;
      }
      try {
        wakeLock = await navigator.wakeLock.request('screen');
        document.getElementById('wakeLockBadge').style.display = '';
        wakeLock.addEventListener('release', () => {
          document.getElementById('wakeLockBadge').style.display = 'none';
          wakeLock = null;
        });
        console.log('[Visitor] Wake lock acquired');
      } catch (e) {
        console.warn('[Visitor] Wake lock failed:', e);
      }
    }

    async function releaseWakeLock() {
      if (wakeLock) {
        try { await wakeLock.release(); } catch (e) { /* already released */ }
        wakeLock = null;
        document.getElementById('wakeLockBadge').style.display = 'none';
      }
    }

    // Reactivate wake lock on visibility change
    document.addEventListener('visibilitychange', async () => {
      if (document.visibilityState === 'visible' && es && !wakeLock) {
        await requestWakeLock();
      }
    });

    const statusEl = document.getElementById("status");
    const transcriptLog = document.getElementById("transcriptLog");
    const chunksReceivedEl = document.getElementById("chunksReceived");
    const queueSizeEl = document.getElementById("queueSize");

    function setStatus(className, text) {
      statusEl.className = 'status ' + className;
      statusEl.textContent = text;
    }

    function addTranscript(text) {
      const p = document.createElement("p");
      p.textContent = text;
      transcriptLog.prepend(p);

      // Keep only last 15 items
      while (transcriptLog.children.length > 15) {
        transcriptLog.removeChild(transcriptLog.lastChild);
      }
    }

    function updateStats() {
      chunksReceivedEl.textContent = chunksReceived;
      queueSizeEl.textContent = queue.length + (speaking ? 1 : 0);
    }

    function showNoChunkWarning() {
      document.getElementById('noChunkWarning').style.display = 'block';
    }

    function hideNoChunkWarning() {
      document.getElementById('noChunkWarning').style.display = 'none';
    }

    // ==========================================
    // CHUNK SEQUENCE ORDERING (P1)
    // ==========================================

    function processChunk(data) {
      const { text, seq } = data;

      if (seq <= lastProcessedSeq) {
        console.log('[Visitor] Chunk duplicato scartato:', seq);
        return;
      }

      if (seq === lastProcessedSeq + 1) {
        enqueueAndSpeak(text, currentLang);
        lastProcessedSeq = seq;
        processPendingInOrder();
      } else {
        pendingChunks.set(seq, { text, receivedAt: Date.now() });
        console.log(`[Visitor] Chunk #${seq} fuori ordine, in attesa (ultimo: ${lastProcessedSeq})`);
        scheduleProcessPending();
      }
    }

    function scheduleProcessPending() {
      if (pendingTimer) return; // gi√† schedulato
      pendingTimer = setTimeout(() => {
        pendingTimer = null;
        const nextExpected = lastProcessedSeq + 1;
        if (pendingChunks.has(nextExpected)) {
          const chunk = pendingChunks.get(nextExpected);
          pendingChunks.delete(nextExpected);
          enqueueAndSpeak(chunk.text, currentLang);
          lastProcessedSeq = nextExpected;
          // Rischedula per il successivo
          if (pendingChunks.size > 0) scheduleProcessPending();
        } else if (pendingChunks.size > 0) {
          // Il seq atteso non √® arrivato: salta ai pending disponibili
          const oldest = Math.min(...pendingChunks.keys());
          if (oldest > nextExpected) {
            console.warn('[Visitor] Chunk persi, salto a seq:', oldest - 1);
            lastProcessedSeq = oldest - 1;
            scheduleProcessPending();
          }
        }
      }, 280);
    }

    function processPendingInOrder() {
      while (pendingChunks.has(lastProcessedSeq + 1)) {
        const chunk = pendingChunks.get(lastProcessedSeq + 1);
        pendingChunks.delete(lastProcessedSeq + 1);
        enqueueAndSpeak(chunk.text, currentLang);
        lastProcessedSeq++;
      }
    }

    // ==========================================
    // AUTO-PRESET ON BACKLOG (P3)
    // ==========================================

    function checkBacklogAndAdaptPreset() {
      const estimatedBacklogSeconds = queue.length * 2;

      if (estimatedBacklogSeconds > 6) {
        fetch('/preset-suggest', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ lang: currentLang, preset: 'simultaneous' })
        }).catch(() => {});
      } else if (estimatedBacklogSeconds < 2) {
        fetch('/preset-suggest', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ lang: currentLang, preset: 'natural' })
        }).catch(() => {});
      }
    }

    function pickVoice(lang) {
      const voices = window.speechSynthesis.getVoices() || [];
      const matching = voices.filter(v => (v.lang || "").toLowerCase().startsWith(lang));

      if (matching.length === 0) return null;

      // Prefer local voices (better quality, no network dependency)
      const localVoices = matching.filter(v => v.localService === true);

      // Prefer Google/Microsoft voices (higher quality on desktop)
      const premiumVoice = matching.find(v =>
        /google|microsoft|apple/i.test(v.name) && v.localService
      );
      if (premiumVoice) return premiumVoice;

      // Fallback to any local voice
      if (localVoices.length > 0) return localVoices[0];

      // Last resort: any matching voice
      return matching[0];
    }

    async function warmupTTS(lang) {
      return new Promise((resolve) => {
        const tryPick = () => {
          preferredVoice = pickVoice(lang);
          console.log('[Visitor] Selected voice:', preferredVoice?.name || 'default', preferredVoice?.lang || lang);
          resolve();
        };
        window.speechSynthesis.onvoiceschanged = tryPick;
        tryPick();
      });
    }

    function speakNext(lang) {
      if (speaking || queue.length === 0) {
        updateStats();
        return;
      }

      const text = queue.shift();
      const u = new SpeechSynthesisUtterance(text);

      if (preferredVoice) u.voice = preferredVoice;
      u.lang = preferredVoice?.lang || lang;
      u.rate = 1.0;
      u.pitch = 1.0;
      u.volume = 1.0;

      speaking = true;
      speakingStartedAt = Date.now();
      setStatus('speaking', 'üîä Riproduzione...');
      updateStats();

      // Clear any previous watchdog
      if (ttsWatchdog) clearInterval(ttsWatchdog);

      // Watchdog: setInterval(1s) checks elapsed time AND backlog before canceling
      const watchdogMs = getWatchdogTimeout(text);
      ttsWatchdog = setInterval(() => {
        if (!speaking) { clearInterval(ttsWatchdog); ttsWatchdog = null; return; }
        const elapsed = Date.now() - speakingStartedAt;
        if (elapsed >= watchdogMs && queue.length >= 1) {
          console.warn(`[Visitor] TTS watchdog: elapsed ${elapsed}ms, backlog ${queue.length}, forcing recovery`);
          clearInterval(ttsWatchdog);
          ttsWatchdog = null;
          window.speechSynthesis.cancel();
          speaking = false;
          speakNext(lang);
        }
      }, 1000);

      u.onend = () => {
        speaking = false;
        if (ttsWatchdog) { clearInterval(ttsWatchdog); ttsWatchdog = null; }
        setTimeout(() => {
          if (queue.length > 0) {
            speakNext(lang);
          } else {
            setStatus('connected', 'üü¢ Connesso - In ascolto');
          }
        }, 100);
      };

      u.onerror = (e) => {
        console.error('[Visitor] TTS error:', e);
        speaking = false;
        if (ttsWatchdog) { clearInterval(ttsWatchdog); ttsWatchdog = null; }
        setTimeout(() => speakNext(lang), 100);
      };

      console.log('[Visitor] Speaking:', text.substring(0, 50) + '...');
      window.speechSynthesis.speak(u);
    }

    function enqueueAndSpeak(text, lang) {
      const cleaned = text.trim();
      if (!cleaned) return;

      queue.push(cleaned);

      // If queue too long, merge oldest pairs (never interrupt, never lose content)
      while (queue.length > 10 && queue.length >= 2) {
        const first = queue.shift();
        const second = queue.shift();
        queue.unshift(first + ' ' + second);
        console.log('[Visitor] Queue merged:', (first + ' ' + second).substring(0, 50));
      }

      addTranscript(cleaned);
      chunksReceived++;
      updateStats();

      // Micro-delay for first chunk after silence to avoid TTS cuts
      if (!speaking && queue.length === 1) {
        setTimeout(() => speakNext(lang), 40);
      } else if (!speaking) {
        speakNext(lang);
      }
    }

    function connectSSE(lang) {
      if (es) es.close();

      queue = [];
      speaking = false;
      window.speechSynthesis.cancel();
      setStatus('connecting', '‚è≥ Connessione...');

      es = new EventSource(`/sse?lang=${lang}`);

      es.addEventListener("hello", (ev) => {
        console.log('[Visitor] Connected to SSE');
        setStatus('connected', 'üü¢ Connesso - In ascolto');
        // Start no-chunk warning monitor
        lastChunkTime = Date.now();
        if (noChunkInterval) clearInterval(noChunkInterval);
        noChunkInterval = setInterval(() => {
          if (es && Date.now() - lastChunkTime > 15000) {
            showNoChunkWarning();
          }
        }, 5000);
      });

      es.addEventListener("ping", () => {
        // Heartbeat - keep connection alive
      });

      es.addEventListener("chunk", (ev) => {
        lastChunkTime = Date.now();
        hideNoChunkWarning();
        const data = JSON.parse(ev.data);
        console.log('[Visitor] Received chunk #' + data.seq);
        processChunk(data);
      });

      es.onerror = (e) => {
        console.error('[Visitor] SSE error:', e);
        if (es.readyState === EventSource.CLOSED) {
          setStatus('inactive', 'üî¥ Connessione persa');
          console.log('[Visitor] Connection closed permanently');
        } else {
          setStatus('connecting', 'üîÑ Riconnessione...');
          console.log('[Visitor] EventSource will auto-reconnect...');
        }
      };
    }

    document.getElementById("start").onclick = async () => {
      const lang = document.getElementById("lang").value;
      currentLang = lang;
      lastProcessedSeq = -1;
      pendingChunks.clear();
      console.log('[Visitor] Starting with language:', lang);

      await warmupTTS(lang);
      connectSSE(lang);
      await requestWakeLock();

      // Start backlog monitoring for auto-preset (P3)
      if (backlogInterval) clearInterval(backlogInterval);
      backlogInterval = setInterval(checkBacklogAndAdaptPreset, 5000);

      // iOS workaround: speak silent utterance to unlock audio
      try {
        const u = new SpeechSynthesisUtterance(" ");
        u.volume = 0;
        window.speechSynthesis.speak(u);
      } catch (e) {
        console.warn('[Visitor] Could not speak silent utterance:', e);
      }
    };

    document.getElementById("stop").onclick = async () => {
      if (es) {
        es.close();
        es = null;
      }

      queue = [];
      window.speechSynthesis.cancel();
      speaking = false;
      if (ttsWatchdog) { clearInterval(ttsWatchdog); ttsWatchdog = null; }
      if (backlogInterval) { clearInterval(backlogInterval); backlogInterval = null; }
      if (noChunkInterval) { clearInterval(noChunkInterval); noChunkInterval = null; }
      if (pendingTimer) { clearTimeout(pendingTimer); pendingTimer = null; }
      hideNoChunkWarning();
      lastProcessedSeq = -1;
      pendingChunks.clear();
      await releaseWakeLock();
      setStatus('inactive', '‚èπ Stop');
      chunksReceived = 0;
      updateStats();
    };
  </script>
</body>
</html>
